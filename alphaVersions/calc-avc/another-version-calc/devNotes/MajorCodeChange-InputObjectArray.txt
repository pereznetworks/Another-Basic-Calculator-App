/* Major Code change:  implement input-object-array ....

    to continue to with ToDo items, and add more features...
        idea from initial #calc code is to ...

    use 1 object array to store and process all input,
        both number and operator values
*/

/* also, refactor for JS ES6 or newer if available ...
    use const and let instead of var
    already using function expression in object-methods
    need to re-check for best practice
*/

/*     1: logic, prototype, usage of Input-object-array...

       values in array would be string values

       prototype object array
         with values demo'ed per case, read into, from array

         inputObject = {
           values: []  .. this.values array starts off empty
         }

        inputs read into array last first;
        so if buttons [5], then [+], then [3] are clicked,
        would be read into input-object-array as;
        [0:5]
        [0:+], [1:5]
        [0:3], [1:+], [2:5]

        object array would be:
          inputObject = {
            values: ['3', '+', '5']
          }

          length of array: indexValue:
              inputObject.values.length

          reading into end of array:  push()

              arrayLength = inputObject.values.push(stringValue):

          reading from and removing from end of array: pop()
              will then need to test stringValue,

              stringValue = inputObject.values.pop()
              isNaN( parseInt(stringValue, 10) )

          reading into beginning of array: unshift()

            arrayLength = inputObject.values.unshift(newInputStringValue)

              for new number input, read into beginning of array
                newNumber += $(this).text();
                arrayLength = inputObject.values.unshift(newNumber);

              for new operator input, read into beginning of array
                operator = $(this).text();
                arrayLength = inputObject.values.unshift(operator);
                opStatus += 1;

        .. once 2nd math operator entered, such as
            ....  [0:/], [1:3], [2:+], [3:5]

        object array would be:
          inputObject = {
            values: ['/', '3', '+', '5']
          }
        .. because of click event handlers, can be 99% sure what type values will be
        .. for a calc, end of array processed, one at a time
        assigning last value of array and popping off end;  remaining in array would be ...
         <5> numValue1 = makeInt(inputObject.values.pop()); [0:/], [1:3], [2:+]
        <'+'> operator = inputObject.values.pop(); [0:/], [1:3]
         <3> numValue2 = makeInt(inputObject.values.pop()); [0:/]

        .. calculating as .....                     5 + 3 = 8
             if (operator == '+') {
                total = numValue1 + numValue2;
             }
             answer = total.toString(10);

        total would be read into end of array;
              arrayLength = inputObject.values.push(answer):  [0:/], [1:8]

        object array would be:
          inputObject = {
            values: ['/', '8']
          }

        then more values entered;              [0:=], [1:2], [2:/], [3:8]

        object array would be:
          inputObject = {
            values: ['=', '2', '/', '8']
          }

        ..then with equals, as with any other math-op
        .. end of array processed,
        assigning last value of array and popping off end;  remaining in array would be ...
         <8> numValue1 = makeInt(inputObject.values.pop()); [0:=], [1:2], [2:/], [3:8]
        <'/'> operator = inputObject.values.pop(); [0:=], [1:2],
         <2> numValue2 = makeInt(inputObject.values.pop()); [0:=],
         <=> clearedValue = inputObject.values.shift();
                  or wait until after calc to replace with answer value...

        .. and calc  as...     8 / 2 = 4
        if (operator == '+/') {
           total = numValue1 / numValue2;
        }
        answer = total.toString(10);

        total would be only value in input-object-array;
          inputObject.values.[0] = answer:       [0:4]

        object array would be:
          inputObject = {
            values: ['4']
          }

        .. user could do allClear or Clear..

        clearing just last entered value: shift()

            clearedValue = inputObject.values.shift();
               previous cleared value being erased each time

        object array would be:
          inputObject = {
            values: []
          }

        .. or keep entering values,
        answer value read into end of array,
        new input values read into beginning of array
*/

/*     2: so input and calc process flow ....

        new values read into beginning of array

            as proActive step: test arrayLength == array.length
              if array processed correctly, and arrayLength updated properly
                arrayLength == array.length will always evaluate to TRUE
              else ... do some error handling

            if number, read into beginning of array, shifting existing values over
            get new arrayLength

            if operator, read into beginning of array, shifting existing values over
            get new arrayLength
             opStatus += 1
              if opStatus >= 2, do math (opStatus == 1, so no math),

            if number, read into beginning of array, shifting existing values over
            get new arrayLength

            if operator, read into beginning of array, shifting existing values over
            get new arrayLength
            if opStatus >= 2, do math (opStatus == 2, so do math)
              pop off values from end of array, assigning to respective vars
              subtotal or total converted, using toString
                and read in place of only value in array[0],
                after a calc with equals, opStatus reset to 1
                after a calc with other math-Ops, opStatus keeps incrementing
                get new arrayLength
*/

/*      3: adjustment to event click handlers...

          each click event handler will need to access array

            allClear: will reset entire array, (still need method for this )

            clear: will only most remove recent value entered from array

            for each of the following, will need to test arrayLength == array.length

            numbers: instead of reading into simple string var, newNumber,
                      will read, unshift(), into array at index [0] as string value,
                          most recent first
                      opStatus += 1 (indicating ready for a calc) is incremented)
                      get new arrayLength


            operators: instead of reading math-Op value into simple string var, operators
                      will read, unshift(), math-Op value into array at index [0], most recent most first
                      opStatus += 1, get new arrayLength
                      then ...
                      if opStatus == 1, then no math calc is NOT performed
                      if opStatus == 2, do math, calc is performed
                      removing last three values from array (num, op, num)
                       after calc, subtotal will read into end of array
                       after a calc with math-Op, opStatus allowed to keep incrementing

            eqauls: will do calc only,
                    if opStatus >= 1, do math calc,
                    removing last three values from array (num, op, num)
                     after calc, subtotal will read into end of array
                     after a calc with equals, opStatus reset to 1
                    removing last four values from array,
                       since successive mathOps calc a subtotal and read into end of array
                          array will be (equals, num, op, num or subtotal)
                          get new arrayLength
                    after calc, total will read into array,
                        total will be only value in array
                        get new arrayLength

           simple vars that may no longer be needed:
                    string prevNumber

           simple var that may still be needed:
                    string newNumber
                    string operator
                    int numValue1
                    int numValue2
                    int total
                    int subtotal
                    string answer
*/

/* To Do :
  1: currently, switching math operators requires first hitting equals, "="
      add code so to enable: key combinations like [9] [/] [3] [+] [2] [=] can display "5"

  2: change calc operation to that same button used for AC and C
      toggles so that when there are values being entered, button is C
        when entered values are reset to default, but calc'ed sum present, button is AC
*/

/* update:
    // 12/15: added library danielsMath.js - mathOp object
            // mathOp.calc: if-if/else statement to math operation
            // mathOp.makeInt: parseInt and if(isNaN) assign 0 to value
            // mathOp.allClear: clears or reset values to 0
            // mathOp.resetValue() resets input number values to 0
            //
            // enabled subtotal with math-operators after initial math operator
            //
            // enabled input of two-digit numbers, 10 and higher values
*/

/* current operation steps: */

  /* default values
    sum value and number values start at 0, number string at " "
  */

  /* number button clicked
     read number button input to string until math operator button clicked
     test new-number-string test length, display number
  */


  /* a math operator button or equals button clicked

     if only one math operator
        new-number-string assigned as previous-number-string
        reset new-number value to ''
     read math operator button input into string opValue
     no math calc done, only 1 math operator
  */


  /* Only do math if two math operators have been inputed
       add new code here convert equals operator click event handler for all math operator buttons
       parseInt(10) from new-number-string into num-Value2
       parseInT(10) from previous-number-string into numValue1
       if numValue2 is NaN, assign a value of 0 to numValue2

       check for <opValue>
          calc: sum = sum <opValue> (numValue1 + numValue2)
            this keeps a running balance
              but equals button has to be clicked

        convert sum.toString(10) into answer string

        read answer string into calc input/display field
        check length of answer string using testNumLength, which fixes it

        new-number-string reset to " "
        assign subtotal tp previous-number-value
        allow operators-inputted-status to cont to be incremented
  */

  /* number button clicked
     read number button input to string until math operator button clicked
     test new-number-string test length, display number
  */

  /* a 2nd math operator input, do math
     a math operator button clicked

     new-number-string assigned as previous-number-string
     read math operator button input into string opValue

         parseInt(10) from new-number-string into num-Value2
         parseInT(10) from previous-number-string into numValue1
         if numValue2 is NaN, assign a value of 0 to numValue2

         check for <opValue>
            calc: sum = sum <opValue> (numValue1 + numValue2)
              this keeps a running balance
                but equals button has to be clicked

          convert sum.toString(10) into answer string

          read answer string into calc input/display field
          check length of answer string using testNumLength, which fixes it

          new-number-string reset to " "
          assign subtotal tp previous-number-value
          allow operators-inputted-status to cont to be incremented

      if equals clicked
        allow math calc if opStatus >= 1, opr at least 1 math operator inputted
        then same as above
          but total assigned to previous-number-value
          operators-inputted-status reset to 1

  */

/* prototype object with math for integer and calculator methods

      const mathOp = {

          makeInt: function (stringValue) {
              let numValue = parseInt(stringValue, 10);
              if ( isNaN(parseInt(stringValue, 10)) ) {
                  numValue = 0;
                  console.log("numValue set to 0, stringValue, '" + stringValue + "', could not be converted into an integer")
                  }
              return numValue;
          },

         calc: function (numValue1, operator, numValue2) {
            let sum = 0;
            if (operator === "+") {

               sum = sum + (numValue1 + numValue2);
               console.log("sum is: " + sum);

              } else if ( operator === "-") {

               sum = sum - (numValue1 + numValue2);
               console.log("sum is: " + sum);

             } else if ( operator === "/") {

               sum = sum / (numValue1 + numValue2);
               console.log("sum is: " + sum);

             } else if ( operator === "*") {

               sum = sum * (numValue1 + numValue2);
               console.log("sum is: " + sum);

             }
             return sum;
         }
      }
 */
